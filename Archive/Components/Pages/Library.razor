@page "/library"
@using Microsoft.EntityFrameworkCore
@using Archive.Models
@using Archive.Data
@inject IServiceScopeFactory ScopeFactory
@rendermode InteractiveServer

<PageTitle>My Collection</PageTitle>

<div class="container-fluid">
    <div class="d-flex justify-content-between align-items-center mb-4">
        <h1>üìö My Collection (@books.Count items)</h1>
        <button class="btn btn-outline-secondary" @onclick="LoadBooks">üîÑ Refresh</button>
    </div>

    @if (isLoading)
    {
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    }
    else
    {
        <div class="table-responsive">
            <table class="table table-hover table-striped">
                <thead class="table-dark">
                    <tr>
                        <th>Title</th>
                        <th>Author</th>
                        <th>Format</th>
                        <th>Size</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var file in books)
                    {
                        <tr>
                            <td>
                                <strong>@file.Book.Title</strong>
                                <br/>
                                <small class="text-muted">@file.FileName</small>
                            </td>
                            <td>@file.Book.Author</td>
                            <td>
                                <span class="badge bg-secondary">@file.Extension</span>
                            </td>
                            <td>@FormatSize(file.SizeBytes)</td>
                            <td>
                                <button class="btn btn-sm btn-danger" @onclick="() => DeleteFile(file)">üóëÔ∏è</button>
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
        </div>
    }
</div>

@code {
    private List<LibraryFile> books = new List<LibraryFile>();
    private bool isLoading = true;

    protected override async Task OnInitializedAsync()
    {
        await LoadBooks();
    }

    private async Task LoadBooks()
    {
        isLoading = true;
        // We use a Scope to get a fresh DbContext. 
        // This is best practice in Blazor Server to avoid threading issues.
        using (var scope = ScopeFactory.CreateScope())
        {
            var db = scope.ServiceProvider.GetRequiredService<LibraryDbContext>();
            
            // We include the 'Book' data so we can display Title/Author
            books = await db.LibraryFiles
                            .Include(f => f.Book)
                            .OrderBy(f => f.Book.Title)
                            .ToListAsync();
        }
        isLoading = false;
    }

    private async Task DeleteFile(LibraryFile file)
    {
        bool confirm = await Task.FromResult(true); // Add JS confirm dialog later
        if (confirm)
        {
            using (var scope = ScopeFactory.CreateScope())
            {
                var db = scope.ServiceProvider.GetRequiredService<LibraryDbContext>();
                
                // Find and remove from DB
                var fileToDelete = await db.LibraryFiles.FindAsync(file.Id);
                if (fileToDelete != null)
                {
                    db.LibraryFiles.Remove(fileToDelete);
                    await db.SaveChangesAsync();
                }
            }
            // Remove from UI list
            books.Remove(file);
        }
    }

    // Helper to make bytes readable (e.g., 1048576 -> "1.00 MB")
    private string FormatSize(long bytes)
    {
        string[] suffixes = { "B", "KB", "MB", "GB" };
        int counter = 0;
        decimal number = (decimal)bytes;
        while (Math.Round(number / 1024) >= 1)
        {
            number = number / 1024;
            counter++;
        }
        return string.Format("{0:n1} {1}", number, suffixes[counter]);
    }
}